%http://www.restapitutorial.com/lessons/whatisrest.html
%https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
%http://rest.elkstein.org/
%https://en.wikipedia.org/wiki/Representational_state_transfer
%https://smartbear.com/learn/api-design/what-is-hypermedia/
%http://www.beabetterdeveloper.com/2013/07/why-rest-is-so-important.html
%https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/W0ca2fa980cd2_4596_8e7b_92f8f0c1fa05/page/REST+Principles+Review+(v.62)

Why Rest? State transfer > Remote Procedure Calls(RPC)/SOAP - less complexity
Rest low overhead

\section{What Is REST}
REST is an architectural style for distributed hypermedia systems.
Rest is also defined as a hybrid style due to its constraints being derived from several other network-based architectural styles.
The idea is that rather than using complex protocols such as Remote Procedure Calls (\textbf{RPC}) to connect between entities, the simpler HTTP requests are used instead.
Originally defined in 2000 by Roy Fielding in his doctoral dissertation, \citep{fielding2000rest}, REST establishes a set of constraints that when adhered to positively impacts the following set of non-functional properties.
\begin{itemize}
    \item Performance
    \item Scalability
    \item Simplicity
    \item Visibility
    \item Portability
    \item Reliability
\end{itemize}
An application that adheres to the constraints of REST is considered to be RESTful.
Next we will mention each of the constraints and how they relate to the aforementioned non-functional properties.

\begin{description}
    \item [Client-Server] The first constraint we will discuss is derived from the hierarchical style client-server.
    Separation of concern is the underlying concept for client-server architecture, in essence the client serves as a trigger process, and the server as a reactive process.
    As the reactive process the server more often than not a non-terminating process waiting for a request from a trigger.
    When a client requests data, the client cares not for how the data is acquired, nor for how it is stored, as long as it is received in the agreed upon format.
    Likewise the server cares not for how the client represents the data, nor for which state the client is in as long as requests are made in the agreed upon format.
    This separation of concern affects three of the aforementioned non-functional properties.
    \begin{itemize}
        \item Simplicity: By not having to consider client specific data, components are easier to represent.
        \item Scalability: Simpling the server components and also increase the scalability of the server. Furthermore the separation allows for components to evolve independently
        \item Portability: By removing concerns between server and client specific details, significantly improving the portability of client side code, as only the language between the two is important.
    \end{itemize}
    %Scalability, Simplicity, Portability 
    \item [Stateless] Adding to the constraints we further require that communication between client and server must be stateless.
    In making communication stateless, all requests must contain every bit of information required to perform the request, i.e. no context stored on the server can be used.
    As with most choices this also has its downside, with no context available the overhead for each request may be higher for repetitive requests.
    Making the communication stateless does however improve visibility, reliability and scalability.
    \begin{itemize}
        \item Visibility: Visibility is increased as there is no need to look beyond the request in order to discern the purpose of the request contrary to RCP.
        \item Reliability: Reliability is increased as partial failures are more recoverable by completely removing the chance for invalid states.
        \item Scalability: Scalability is improved by not having to store information regarding temporary states
    \end{itemize}
    %Performance, Scalability, Simplicity, Visibility, Reliability
    \item [Cacheable] 
    In order to increase efficiency the constraint of cacheable data is added.
    The constraint requires that when a response to a request specifies whether the data is cacheable or non-cacheable which may remove the need for a later request.
    When a response is noted as cacheable, a timeout is also required which the client must adhere to.
    This constraint may slightly reduce reliability if the data in the cache becomes outdated before timeout, however for GIRAF this should not be an issue.
    Other non-functional properties that are positively affected are scalability and performance.
    \begin{itemize}
        \item Scalability: By clients not having to always request, the server can service more clients within a given timeframe.
        \item Performance: With some requests not needing a response from the server but can be partially or completely handled through the cache, average latency is improved.
    \end{itemize}
    %Performance, Scalability, Reliability
    \item [Uniform Interface] 
    As with all generalisation efficiency is affected as one cannot tailor the interface to a systems unique needs.
    \begin{itemize}
        \item 
        \item 
    \end{itemize}
    %Simplicity, Visibility
    \item [Layered System]
    \begin{itemize}
        \item 
        \item 
    \end{itemize} 
    %Performance, Scalability, Simplicity
    \item [Code on Demand] 
    \begin{itemize}
        \item 
        \item 
    \end{itemize} 
    %Simplicity, Visibility 
\end{description}