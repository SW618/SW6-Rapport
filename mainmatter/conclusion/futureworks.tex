\chapter{Future Work on GIRAF}\label{chp:futureworks}
In this chapter we present the immediate work that we believe would benefit GIRAF the most.
This chapter will not be a complete list of all the work to be done, rather it will be contained to the areas of GIRAF where we have been involved the most throughout the projects; this means we will discuss improvements in regards to Pictosearch, the Week Schedule App, the GIRAF Launcher and of course the REST API.
The REST API affects the future of most apps including the ones we already mentioned, as such we will start by explaining what is missing from the REST API as well as argue why we believe that the REST API should be prioritised.

This list is not solely compiled from our point of view, as it is the result of a final meeting with representatives from each group at which we spoke of the degree to which we had achieved our goals as well as what we believed would be best for the development of GIRAF to continue with.
Aside from these features we also suggest what development processes we would use if we were to continue working on the project.
%Limit this to what we have been involved in

\section{Feature Suggestions}
This section discuss the different features that still need to be implemented or changed in GIRAF, to give an idea of what still requires work.
\kim{You should not only point out the problems but also suggest solution, where it make sense. for each problem that you discuss then I would like an analysis of what features/qualities a solution should have and a proposal of a design that conforms to these requirements.}\todo[inline]{This note has been considered, do consider it while reading again tho}

\subsection*{REST API}
Once the REST API is implemented in GIRAF, synchronisation between both client and server but also between clients themselves, will be possible.
This is something that we believe is mandatory before GIRAF could ever be proclaimed as even close to finished.
Despite being discouraged by the previous developers telling us to ignore synchronisation as it would not be reachable within one semester, we believe it detrimental to the quality and usability of GIRAF and as such the implementation and use of the REST API should be the primary goal for the following semester.
Moreover this synchronisation is also a thing the costumer wants implemented.
It is worth noting here that simply because we find this to be the most important other things should not be neglected, a lot of the REST API is internally blocking and requires plenty of collaborative work between groups, as such putting too many developers on this task may slow down the overall possible development.

The areas that yet need to be worked on for the REST API are
\begin{itemize}
\item Login
\item Endpoints
\item Client--side implementations,
\item Web administration
\end{itemize}
Our group has not been involved in developing the new login system and thus we will not discuss that further, web administration is yet untouched so for that we will simply explain why it is needed and how it relates to the REST API.

\kim{I dont understand why there is not a login section, I understand that you have not worked with it this semester, but you havent worked on the web adimistration interface either, however it have a subsub section explain the problem.}
\todo[inline]{Jeg ved ikke rigtig noget om login så tænker vi enten sletter Web admin subsub eller snakker med Jespers gruppe så vi kan skrive lidt om login}

\subsubsection*{Endpoints}
While a number of endpoints and their corresponding models have been finished this year, more remain undone before the current applications can rely solely on the REST API for data.
Currently endpoints exist for users, departments, the derivatives of frames, and week schedules.
This however is not enough as different data exists for other applications in GIRAF, namely maps and game settings for both Voicegame and Categorygame, as well as categories themselves.
Since Voicegame is now available as a standalone app one must consider the difference between whether it was launched as standalone or through the GIRAF launcher.
Furthermore administrative data such as user settings is also not yet available through the REST API.
Depending on which launch method is used, the data available in the app should change.
For the sake of being launched as a standalone app no data can be retrieved from the API, as such one might consider using local storage, as it does currently, for when the app is launched standalone, however for when it is launched through the launcher and thus is related to a user and a department, it may retrieve data from the REST API.
All of these must be constructed before GIRAF can fully migrate to use the REST API rather than the current database.

Of the endpoints that we have been developing, started on \myref{chap:s3task} and continued at \myref{chap:s4task} a few services have yet to be constructed.
For Week Schedule the services to delete a Week Schedule and to update user progress are not available.
However we made a branch in the REST API Git repository for the next years students to continue working in.
The conflict handling also still need to fine tuned such that less conflicted copies will be created.
In \myref{ssec:policy} we mentioned the quite simple offline policy that currently exists, however with timestamps on both week schedules and week days, as described in \myref{sec:restws}, a more refined implementation using the same basic idea can be used in the PUT requests.
In addition there is no service available that enables searches for pictograms, in a more complete way than: ``\% LIKE \%'' in SQL, and there is currently no ranking amongst the result.
This solution is quite crude and inefficient, allowing advanced search criteria, limiting results via paging or lazy loading as well implementing a sensible ranking system using statistics from GIRAF are all ideas that can provide a faster search and more precise search tool than simply searching for a substring.


\subsubsection*{Client--Side Implementation}
Once all the endpoints are completed, or before that even, client--side implementations must be made in order to utilise the REST API.
In general one primary concern remains here which we have not discussed as it has not been important.
Either some module that translates data to GIRAF's current format must be developed, or the apps must be refactored as to use the same models as the REST API.
An example here would be the Week Schedule model and endpoint that we have developed.
Our model uses a class \texttt{WeekSchedule} with an \texttt{enummap} to map \texttt{Weekdays}, where the app currently uses nested sequences instead.
Either the data retrieved and sent to the REST API must enter a translation process or the app should undergo a refactoring process as to use something that more closely resembles the model used by the REST API.
The reason for the difference is that we were dissatisfied with the degraded model used by the app, and thus decided to improve the model to retain a high code quality in the REST API.
As for choosing between one or the other, refactoring may take longer and be the best long term solution, while a translation module may be a faster solution, but worse in the long term and make it harder for future developers to use.

As aforementioned some Client--Side implementation may need to consider a secondary storage, like local, in the case they at some point become standalone apps which do not use the login system.

\subsubsection*{Web Administration}
Once a working REST API has been established, web administration should be implemented concurrently with the client--side implementations.
In its current state the only way to add users, departments or any other administrative information is by database access, this should be changed such that the department can add new citizens or guardians when needed.
The reason we believe that a web tool would be the way to solve this, is because the customers has asked for this to be available on their computers, and having it as a web application would made it a simple task to adjust the web application to support tablets should they at a later point want access from such devices.
\kim{This section is going the right direction, try to elaborate on the problem side a bit more. Also add some technical details to the solution part. Describe how it should you the API, what challenges need to be solved etc. }

In developing such a web administration tool one must not only consider what incoming requests much be supported, but how are the tablets affected by changes through the web administration tool.
Furthermore changes may be required to the endpoints in the case that some service required for the web administration tool was not considered originally.
\todo[inline]{is this enough?}

\subsection*{Week Schedule}
Significant progress on Week Schedule have been made during this year, our primary involvement is described on \myref{sec:WSScroll}, plenty of features to improve quality of life when using the application have been developed, yet it still needs to implement the REST API.
As such the goal for Week Schedule in the coming year should be to start using the REST API.
This also means that perhaps more services for the Week Schedule must be created in the case where the current services prove insufficient.
As for starting to use the REST API we would suggest a significant refactoring of Week Schedule such that the model more closely resembles that of the REST API, rather than creating a module that translates data as best as it can.
This opinion is based on our experience with Week Schedule from which it is very clear that the model was not entirely thought through when it was originally established, and has since then just had components added as separate developers sought fit.

Refactoring this would create a significantly better overview of the model, and make it far easier to make small adjustments when Week Schedule enters a try--out phase, which is what we believe should be prioritised after REST API implementation.
With the REST API an opportunity to fix some of the issues that currently exist also presents itself, in particular this relates the progress.
When we inherited GIRAF, progress was saved to a local file on the tablet, not even to the local database, furthermore the states a frames can be in is presented as booleans whereas an enum would make more sense, e.g. a frame could be canceled and finished at the same time.
These choices are a result of continuously making quick fixes each semester and have resulted in the whole progress feature not fully working and having odd interactions causing bugs that have not been fixed.
Refactoring the progress system alongside implementing the REST API may solve issues that are caused as a result of degraded code.

\subsection*{Launcher}
While our involvement in the Launcher largely relates to enabling offline mode, as discussed in \myref{ssec:policy}, these changes are for the most part irrelevant without synchronisation as technically there is no difference between online and offline mode.
As for the handling of conflicts and merging, this should be handled by the REST API PUT requests rather than the apps, and as such must be considered when developing endpoints.
Beyond ensuring offline availability, security and login should be the primary aspects considered for the Launcher.
Security refers not only to access levels of data, but also how long data is stored as well as the encryption of data.
The login part is closely connected with the aforementioned login part of the REST API, which we have not been a part of and thus our knowledge of it is limited.

\subsection*{Pictosearch}
For Pictosearch the immediate work to be done is less reliant on the REST API than most of the other areas we have been included in, although REST API will still affect it slightly.
The goals for Pictosearch was to make it more responsive and faster, while making it more responsive and changing how to initialise the search creates the experience that it is faster, it still searches as slow as before.
For this reason in regards to the Pictosearch app one should look at perhaps improving the search algorithm.
Beyond improving the search algorithm a variety of other improvements come to mind, examples of better search algorithms would be Boyer-Moore and Knuth-Morris-Pratt \citep{BoyerMoore} \citep{KnuthMorrisPratt}.
Through either lazy loading or pagination the search experience could also be improved, this however leads us to a second problem that should be fixed in regards to the search.
The results of a search are ordered by their internal ID, when in reality it should be ordered by how closely it resembles the search string, e.g. a search for apple, should have apple to be the first shown pictogram, not pineapple or apple juice.
Here one could also return frequently used pictograms first etc.
Further improvements involve adding categories and sequences to the search results, in the case of sequences this could benefit from implementing the REST API and making adjustments for the REST API model, as the model in the REST API have \texttt{Sequence} and \texttt{pictogram} inherit from the same super class.
Lastly if categories and sequences were to be added to the search, perhaps some sort of search settings could be added as well such that one could filter the search.

\section{Development Process Suggestions}
This section presents our suggestions for the development process for students working on GIRAF.

\begin{description}
	\item[Pair Programming] \hfill \\
	We advice that the next year's students will use pair programming especially in the start of the project.
	There are many different elements to keep track of when starting to use and develop further on a code-base, especially one as GIRAF where a good structure might be missing in some places as we came to experience in the first two sprints in particular Week Schedule as we elaborated on in \myref{sec:restws}.
	As mentioned before, we gained a lot from pair programming especially bringing everyone up to speed, and ensuring that everyone in the group was able to develop further on the project.

	\item[Code--Review] \hfill \\
	Although we had some bad experiences with Code--review, we still see the potential in having them for design purposes.
	We advice that the next year's students will continue having Code--reviews, but instead of having them very loose, set--up a guideline for how to do a proper code--review.
	A guide should entail, what to look for in a code-review, how to give feedback, and what things are not necessarily \textit{comment-worthy}.

	\item[Phabricator] \hfill \\
	We strongly advice that they continue to use the tool Phabricator, to have a product backlog, as well as a good tool for code-review, and creating an overview of everyone's progress.
	Phabricator has proven a useful tool for us and it has many more features than what we have used throughout the semester, perhaps there exists more features could help the project.
	The biggest hurdle we have had with Phabricator were in the beginning as practically everyone but a single group was new to it, as such some issues with linking user stories to code diffs were an issue, although as we ran into these issues the wiki was updates and thus the following semester can have a better knowledge base than us when starting by simply reading the wiki.
	Furthermore we have had a lot of user stories, which are defined as tasks, on our shared backlog as we simply migrated those that already existed.
	It may be worthwhile to provide a label for all user stories when starting such that it is clear that they existed the previous semester.

	\item[Progress Tracking] \hfill \\
	We faced problems ourselves falling behind on the report in sprint 3, as we used all of our time programming the REST API.
	Other groups were even further behind than us, and we therefore suggest that people consider on a multi-project level that time for the report is also required.
	This should hopefully reduce how far people get on the report, another solution would be to say that a given set of the working day one must be available for multi--project work.
	We suggest this as we were being blocked on REST development due to code review as another group was focusing on their due to them writing just about nothing until the fourth sprint.

	\item[More Evaluation] \hfill \\
	The project have had some evaluation throughout its lifetime from the customer's, but this year at least, PO did not give very good feedback to the rest of the multi--project from the customers.
	We would have appreciated more feedback on the user stories we have done which dealt with application.
	Therefore we advice that internal evaluation could be used.
	This could be included in the code--review where an evaluation plan should be given to the code--reviewer, and when the reviewer tests the application the person who implemented the feature would sit with them and talk about the feature to get feedback outside of the group.
	We do not think this would take much time away from development, and fresh eyes on a problem or feature could only be beneficial.

	\item[Focused Projects] \hfill \\
	We decided to all be very mixed in what we worked on this semester, where they last year had a very designated field of work.
	This was great in the fact that we all know much about the different parts of GIRAF, but it sadly affects the project reports written to lack a sort of structure, which we felt that ours did until we partook in the REST API.
	We advice that every group gets a focus area of GIRAF rather than only of the project, like being in charge of everyone writing proper documentation, or in charge of social events of which we have had none.
	If every group chose an application they would focus on a more traditional style project could be achieved where more in depth problem analysis could be given.
\end{description}
We also advice that the project continue to use Scrum, which is covered in the following section.

\subsection{Scrum}
Scrum has worked great for this project to keep track of how every group was doing and also internally in our own group as the retrospective of sprint 3, and 4 have indicated.
Therefore we greatly advice that next year's students will use Scrum for their project in a way that fits them, not just for the multi--project but also for their internal project structure.
This section will briefly cover the points we thought to be most important for Scrum to succeed for this project.

\begin{description}
	\item[Product Owner] \hfill \\
	The Product Owners have had internal problems this semester which sadly shined through in some aspects.
	The user stories were poorly written, and the communication from the customers to the multi--project fell short of our expectations.
	Therefore we advice that the product owner should be a group which is known to be a resourceful group, and a group which thinks that the task of being product owner is interesting, such that they will put in the required effort.

	\item[Scrumboard] \hfill \\
	Internally we gained much from using the Scrumboard, as it gave us an overview of where our user stories currently stood, and also sparked the conversation at the daily Scrum meeting.

	\item[The Scrum Guide] \hfill \\
	The current Scrum masters did a good job of facilitating the Scrum meetings, and have also written a Scrum guide for next years students which we would recommend for them to follow for their project structure.
\end{description}
