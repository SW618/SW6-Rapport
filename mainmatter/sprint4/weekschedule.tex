\section{REST API: Week Schedule Endpoint}\label{sec:weekscheduleendpoint}
This section will describe our progress in developing the service layer of the Week Schedule part of the REST API.
The userstory is as follows:
\begin{center}
\userstory{As a developer I would like an endpoint for Week Schedules, such that I can retrieve them from the GIRAF REST API.}
\end{center}

We estimated this userstory at 6 EP, unfortunately this was too little time and we did not solve all the sub-tasks involved in the user story.

First we will explain what endpoint we will make, then we will explain how they work.
\subsection{Endpoints}
\myref{tbl:weekscheduleservice} contains the endpoints which are involved in the Week Schedule part of the REST API.

\begin{table}[h]
    \footnotesize
    \centering
    \begin{tabular}{lllr}
        HTTP Request    & Path                                      & Method Name           & Status \\
        \midrule
        GET             & \texttt{/}                                & \texttt{getAll}               & Done \\
        GET             & \texttt{/\{wsid\}}                        & \texttt{getById}              & Done \\
        GET             & \texttt{/\{wsid\}/progress}               & \texttt{getAllProgress}       & Done \\
        GET             & \texttt{/\{wsid\}/progress/\{uid\}}       & \texttt{getProgressByUser}    & Done \\
        \tblgrpsep
        POST            & \texttt{/}                                & \texttt{insertWeekSchedule}   & Done \\
        \tblgrpsep
        PUT             & \texttt{/\{wsid\}}                        & \texttt{updateWeekSchedule}   & Done \\
        PUT             & \texttt{/\{wsid\}/progress/\{uid\}}       & N/A                           & Not Done \\
        \tblgrpsep
        DELETE          & \texttt{/\{wsid\}}                        & N/A                           & Not Done \\
    \end{tabular}
    \caption{List of Week Schedule endpoints, they all exist at \texttt{/department/\{id\}/weekschedule}. \{wsid\} indicates the id of a \texttt{WeekSchedule} and \{uid\} refers to the id of a \texttt{User}.}\label{tbl:weekscheduleservice}
\end{table}

Generally for all these are that the DAOs are used to retrieve, update, store and delete information from the persistence layer.
Most important here is the \texttt{WeekScheduleDao}, which were introduced in~\myref{subsec:weekschedulepersistence}.

\subsection{GET--requests}
The GET requests are very simple, since all they do is they retrieve information using the DAO: \texttt{WeekScheduleDao}.
The most interesting part is that we split the week schedule information and the progress information.
This is done such that only people with access to information can get it in a simple way.
All guardians can access the progress information for all users, and each user can access their own information, but users cannot access other users progress information.
Additionally giving the progress information for all users when requesting one or all week schedules would greatly increase the size of the response, which will both increase server load and bandwidth required.

Developing this also required us to go back to the model and use the annotations \texttt{@JsonProperty} and \texttt{@JsonIgnore} which are provided by Jackson.
We need to \texttt{@JsonIgnore} some information to avoid circular references, since this will lead to infinite recursion when trying to serialize the objects.
An example of this is the relation between \texttt{Department} and \texttt{WeekSchedule}, since they both contain a reference to each-other, requesting one week schedule would yield it and its department, this is turn would yield all that departments week schedules and so on.

\subsection{POST--requests}
There is only one time in which it is needed to create data in association with week schedules, this is naturally when creating them.
Therefore there is only one POST method in the part of the REST API.
To implement this we make a builder to create the \texttt{WeekSchedule}-object.
The builder--class \texttt{WeekScheduleBuilder} contains the information which is required to construct a \texttt{WeekSchedule}.
However it takes the information which the client would send i.e. the ids of the users which are supposed to be attached to it, and not the \texttt{User}-objects as JSON.
An integral part of a \texttt{WeekSchedule} is the \texttt{Weekday}s, it should naturally be possible to upload one or more \texttt{Weekday}s with the \texttt{WeekSchedule}.
Since it is possible to nest builders using RESTEasy and Jackson, we create a \texttt{WeekdayBuilder} to create \texttt{Weekday}s and a \texttt{WeekdayFrameBuilder} to create \texttt{WeekdayFrame}s.
In order to nest the builders properly they should each create the correct object nested from them, i.e. \texttt{WeekdayBuilder} should use \texttt{WeekdayFrameBuilder} to create \texttt{WeekdayFrame}s for it etc.

It is also important that each builder verifies its inputs, e.g. when given the id of a pictogram it should verify that the user which are currently creating the \texttt{WeekSchedule} have access to the pictogram etc.
We also check that the \texttt{WeekSchedule} to be created has a thumbnail which the creator can access, all its users are valid and a title.

\subsection{PUT--requests}
The PUT--requests which are used to change information on existing \texttt{WeekSchedule}.
There are two different PUT--requests which can be made, one will update a \texttt{WeekSchedule} and one will update the progress information for a given \texttt{User} on a given \texttt{WeekSchedule}.
The PUT--requests can quickly get complicated, since they have to deal with synchronisation and conflicts, we have previously discussed this when we in sprint 2 allowed for Giraf to be started offline see \myref{sec:offline_giraf} for more.
In \myref{sec:restws} we describe the \texttt{lastEdit}--variables, we use these to keep track of when the entity was last edited.

We have implemented the simple way of synchronisation which goes as follows:
If the local device have had the newest version, and wants to update, then update the data on the server.
If the local device did not have the newest version, and wants to update, then create a copy, and perpend ``Conflicted Copy: '' to its title.
We previously mentioned this method, which is inspired by Dropbox in \myref{ssec:policy}.

The PUT--request which was meant to update the progress of a user on a given \texttt{WeekSchedule} have not been implemented due to time constraints.
However the code which is responsible for this behavior have been throughly tested in the unittests.

\subsection{DELETE--requests}
We have not implemented the DELETE--requests due to time constrains.
There should only be one endpoint for deletion related to week schedules, this is for deleting the week schedule itself.
If a guardian wishes to remove a user from a week schedule, or delete some frames from a day, then it is an update to an existing week schedule, and is done using the PUT--requests mentioned above.